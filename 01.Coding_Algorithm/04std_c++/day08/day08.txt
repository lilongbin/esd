多继承//可以有多个父类//难点
虚函数/函数重写(函数覆盖)//特重点
多态
动态类型识别
虚析构函数/抽象类

本节是C++的精华(尤其是虚函数和多态)

一/多继承//可以有多个父类//难点
	框架和笔试面试中常常涉及
	Phone Camera Mp3
		IPhone
	class IPhone:public Phone,public Mp3,public Camera{};
	抽取共同部分到一个更高层的类
		Product
	Phone Camera Mp3
		IPhone
虚继承:	
	虚继承来解决钻石继承(菱形继承)
	一个类有多个父类并且这多个父类又有共同的父类就组成了钻石继承(菱形继承);
	可以采用名字隐藏机制,达到合理调用效果;

	虚继承就是让孙子类可以像子类一样去直接访问最高层类的公有数据;请参考图virtual.bmp
二/虚函数
	在函数声明或者定义加了virtual关键字;
	virtual void show();
	一个类型中如果有虚函数则会多出一个指针指向这个类型对应的虚函数表,简称虚表;
三/函数重写(函数覆盖)//特重点
	overload(重载)//在同一作用域中函数名相同参数列表不同的函数构成重载关系;
	overwrite(重写)//在父子类中,子类提供了一个和父类中同名同参列的虚函数;
	namehide(隐藏)//在父类中,子类提供了一个和父类中同名的不带virtual关键字的普通函数,父类函数被隐藏;
	重载的定义
	在同一可访问区内被声名的几个具有不同参数列表的（参数的类型、个数、顺序不同）同名函数，程序会根据不同的参数列表来确定具体调用哪个函数，这种机制叫重载，重载不关心函数的返回值类型。但是，只有返回值相同的同名函数，才有可能构成重载关系。
	重载的相关概念
	1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；
	2、不能通过访问权限、返回类型、抛出的异常进行重载；
	3、方法的异常类型和数目不会对重载造成影响；
	覆盖的定义
	覆盖是指派生类中存在重新定义的函数，其函数名、参数列、返回值类型必须同父类中的相对应被覆盖的函数严格一致，覆盖函数和被覆盖函数只有函数体（花括号中的部分）不同，当派生类对象调用子类中该同名函数时会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本，这种机制就叫做覆盖。
	覆盖的相关概念
	1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
	2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；
	3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
	4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。

	覆盖与重载输入输出参数的比较
	重载的特征有：
	1 相同的范围（在同一个类中）；
	2 函数名字相同；
	3 参数不同；
	4 virtual关键字可有可无。
	覆盖的特征有：
	1 不同的范围(分别位于派生类与基类);
	2 函数名字相同；
	3 参数相同；
	4 基类函数必须有virtual关键字
	隐藏的定义
		隐藏是指派生类的函数屏蔽了与其同名的基类函数。
	隐藏的相关概念
	1 如果派生类的函数与基类的函数同名，但是参数不同。此时不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
	2 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时基类的函数被隐藏（注意别与覆盖混淆）。

四/多态
	当父类对象的指针(或者引用)指向子类对象时 调用父类的虚函数,如果子类重写了这个虚函数,则这个调用的表现是具体子类的表现;
多态的三个条件:
	继承 是多态的基础;//必备
	虚函数 是多态的关键;
	函数重写 是必备条件;

	多态的概念
	面向对象程序设计中一个重要概念是多态性。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。可以把一组对象放到一个数组中，然后调用它们的方法，在这种场合下，多态性的作用就体现出来了，这些对象不必是相同类型的对象。当然，如果它们都继承自某个类，你可以把这些派生类，都放到一个数组中。如果这些对象都有同名方法，就可以调用每个对象的同名方法。同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。多态性通过派生类重载基类中的虚函数来实现。
	● 编译时的多态性
	编译时的多态性是通过重载来实现的。对于非虚的成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现何种操作。
	● 运行时的多态性
	运行时的多态性就是指直到系统运行时，才根据实际情况决定实现何种操作。运行时的多态性通过虚成员实现。
	编译时的多态性为我们提供了运行速度快的特点，而运行时的多态性则带来了高度灵活和抽象的特点。
	void test(CBase *pBase){ pBase->VirtualFun();  }
	这段程序编译的时刻并不知道运行时刻要调用那个子类的函数，所以，编译的时刻并不会选择跳转到那个函数去！
	如果不是虚函数，那么跳转的伪汇编代码应该是call VirtuallFun！
	如果是虚函数，就变成了call pBase->虚函数表里的一个变量，不同的子类在这个变量含有不同的函数地址，这就是所谓的运行时刻。但事实上pBase->虚函数表里的一个变量也是在编译时刻就产生的，它是固定的。所以，运行时刻还是编译时刻，事实上也并不严密，重要的还是理解它的实质！虚函数只是一个函数指针表，具体调用哪个类的相关函数，要看运行时，对象指针或引用所指的真实类型，由于一个基类的指针或引用可以指向不同的派生类，所以，当用基类指针或引用调用虚函数时，结果是由运行时对象的类型决定的。

多态与递归类似，不管是书中还是老师授课，都把其讲得神乎其神，让读者一头雾水，莫名其妙。多态实际上非常简单，学习的难点在于在接触多态之前，缺乏一个感性的认识。
多态允许将子类的对象当作基类的对象使用，某基类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法在代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定。再举个比较形象的例子：
比如有一个函数是叫某个人来吃饭，函数要求传递的参数是人的对象，可是来了一个美国人，你看到的可能是用刀和叉子在吃饭，而来了一个中国人你看到的可能是用筷子在吃饭，这就体现出了同样是一个方法，可以却产生了不同的形态，这就是多态！

多态的意义:
增加了程序的可拓展性,实现了模块之间的解耦；
1. 应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。//继承
2. 派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 //多态的真正作用，以前需要用switch实现

多态的表现(效果):
一个调用语句可以出现/实现多种形态.
比如,在发生多态时,如果传入参数是一个子对象,那么会调用子对象的成员方法,如果传入参数是一个父对象,那么会调用父对象的成员方法.

C++中多态的实现:
C++中多态的实现需要三个条件.
1. 存在继承关系
2. 虚函数；虚函数对多态的实现是必要的,遇到这个处理过程要等到执行时再确定到底调用哪个类的处理过程;
3. 子类重写基类虚函数;基类指针或引用指向子类对象;

C++面向对象三大特性分别是封装,继承,多态. 
封装 站在类的对象作函数参数的角度思考.当类的对象作为函数的参数进行传递时,参数的颗粒度变大,一次性可以传递多个属性和多个方法,突破了C语言的函数的概念. 
继承 使子类可以使用基类的东西,增加了代码的可复用性. 
多态 使基类对象可以使用子类对象写的代码,实现了解耦和;使之前的代码可以执行后来人写的代码,增加了程序的可拓展性和可维护性.

C++实现多态原理:
C++编译器为含有虚函数的类对象提前布局vptr指针,生成虚函数表;当发生多态时(虚函数调用时),去虚函数表中查找调用地址(函数的入口地址).
如果用面向过程的实现就是在接口中使用typeof判断入参并使用switch语句处理不同的类型；而C++直接使用虚函数就可以实现动态绑定；

多态的分类(Java)
1、编译时多态，即方法的重载，从JVM的角度来讲，这是一种静态分派（static dispatch）
2、运行时多态，即方法的重写，从JVM的角度来讲，这是一种动态分派（dynamic dispatch）

从使用角度看多态无非就是三句话：
比如我们有一个基类Basic并定义了虚方法，有一个子类SubClass也实现了自己的方法；
1、向上转型是自动的。即Basic b = new Children()是自动的，不需要强转；
2、向下转型需要强转。即SubClass s = new Basic()是无法编译通过的，必须要SubClass s = (SubClass)new Basic()，让基类知道它要转成具体哪个子类
3、基类引用指向子类对象，子类重写了基类的方法，在调用基类的方法时，实际调用的是子类重写的基类的该方法。即Basic b = new SubClass()，b.toString()实际上调用的是SubClass中的toString()方法；

多态性往往用于面向对象中抽象和具体类的层次设计中，好处就在于提供系统的弹性，避免代码的僵化。
例如，可以增加一个新的子类而不需要修改原代码，避免程序中的复杂的条件分析语句。也就是面向对象中的“对扩展开放、对修改封闭”的原则。


案例
// 多态
// 多态现象：同一个调用语句 可以有多种形态 扔过来一个子类对象，执行子类的API函数 扔过来一个基类对象，执行基类API函数
// 多态成立的三个条件：继承、基类中定义了虚函数、子类重写基类的虚函数 使用时：基类指针（引用）指向子类对象
// 效果：同样一个调用语句可以有多种形态（多种调用方法）

#include <iostream>
using namespace std;

class BasicClass {
	public:
		BasicClass() { cout << "Basic Class init" <<endl; }
		virtual void work() { cout << "Basic Class working" <<endl; }
		virtual ~BasicClass() { cout << "Basic Class deinit" <<endl; }
};

class SubClass: public BasicClass {
	public:
		SubClass() { cout << "\tSub Class init" <<endl; }
		virtual void work() { cout << "\tSub Class working" <<endl; }
		virtual ~SubClass() { cout << "\tSub Class deinit" <<endl; }
};

class SubSubClass: public SubClass {
	public:
		SubSubClass() { cout << "\t\tSub-Sub Class init" <<endl; }
		virtual void work() { cout << "\t\tSub-Sub Class working" <<endl; }
		~SubSubClass() { cout << "\t\tSub-Sub Class deinit" <<endl; }
};

/* 当调用how2Work()函数时表现多态性，根据入参不同调用不同的方法 */
/* 如果父类没有声明为virtual即没有实现多态，传入子类对象时就不会调用子类的方法 */
void how2Work(BasicClass *base)
{
	base->work();
}

int main(void)
{
#ifdef CASE1
	BasicClass *person = NULL;
	person = new BasicClass();
	person->work();
	delete person;
	person = NULL;

	person = new SubClass();
	person->work();
	delete person;
	person = NULL;

	person = new SubSubClass();
	person->work();
	delete person;
	person = NULL;
	/* 虽然都是person->work()结果却有不同的表现 */
#else
	/* 多态的使用最多的是下面这种方式 */
	BasicClass bc;
	SubClass sc;
	SubSubClass ssc;

	how2Work(&bc);
	how2Work(&sc);
	how2Work(&ssc);
#endif

	return 0;
}


五/多态的底层实现
	请参考图vfuntable.bmp
	当父类型指针指向子类对象调用虚函数时,并没有直接生成调用函数的地址;而是根据指向的对象得到虚函数表的地址;然后根据虚函数表中的函数地址调用相应的函数;(这种机制又叫函数的动态绑定)
六/动态类型识别
	多态的作用就是让类型通用编程;
		但降低效率//可以使用静态绑定提高效率
		和让个性消失//可通过类型识别恢复
		因此请看类型识别如何表现
	识别类型
	dynamic_cast<类型>(变量);
		前提必须有虚函数,否则编译失败;
		如果转换成功就返回一个非空指针,失败则返回NULL;
	此外,还有一种技术可以取得类型信息
	typeid取得类型信息(RTTI 运行时类型识别run time type identify);
		要包含#include <typeinfo>头文件
		typeid的返回值是type_info
		name()取得类型的名字
		重载了运算符 
			== //如果type_info相等则类型一致;
			!= //如果type_info不相等则类型不一致;
		当父类对象指针指向子类对象时,要识别子类对象,必须保证父类型中有虚函数,否则就识别成父类型了;
七/虚析构函数
	当父类型的指针指向子类对象时,使用delete释放指针对应的内存空间,会调用父类的析构函数;子类的析构函数的析构行为未定义;
	因此我们要想办法确定子类型的析构;需要在父类的析构函数名前加上virtual关键字,这样就可以在删除父类指针时调用到子类的析构函数;

	总结:
		当父类型中有虚函数时,需要考虑把父类型的析构函数定义成虚析构函数;

八/抽象类
	不用定义对象而只作为一种基本类型用作继承的类叫做抽象类;不能直接实例化但可以留给子类用;
	抽象类的作用是作为一个类族的共同基类,为一个类族提供公共接口,抽象类不能直接实例化出对象;
	除了不能实例化之外和其他类没有任何区别;
	如果类中出现纯虚函数,则这个类被定义为抽象类;
virtual show()=0;//没有具体的实现,后面加=0,有virtual关键字,即是纯虚函数;
	如果抽象类的子类中不定义纯虚函数的实现,则子类也为抽象类;如果子类中定义了纯虚函数的实现,则子类不是抽象类;
	纯虚函数在派生类中重新定义以后,派生类才能实例化出对象;

	接口类是特殊的抽象类,只包含纯虚方法;

C++类，抽象基类，接口类三者间的区别与联系
类是对对象的抽象，抽象类是对类的抽象，而接口是对行为的抽象。
联系很明显，三个都是类

1 结构上的区别
    普通类：数据+方法+实现
    抽象类：数据+方法(一定包含虚方法n>=1)+部分方法的实现
    接口类：方法(纯虚方法)

2 概念上的区别
    普通的类和另外两个的区别很明显，普通类就是猫狗之类的，而抽象类就是动物类。但接口类与抽象类的区别不太明显，下面就说说这两个类。
    接口类算是从抽象类中分离出来的特殊的抽象类(纯虚方法且不含数据的抽象类)，抽象类侧重点在‘类’的角度上，而接口类则侧重于‘方法’。引用《大话设计模式》中的一句话就是，“类是对对象的抽象，抽象类是对类的抽象，而接口是对行为的抽象。”
    举个例子，猫、狗类(普通的具体类)继承于动物类(抽象类)，而猫、狗类又有共同的‘吃饭’的行为，这时，我们就可以写一个‘吃饭’的接口类，让猫、狗类继承并实现这个方法。
    抽象类是从子类中发现公共的东西泛化出父类，从而让子类继承父类，但是你写接口类的时候不一定知道子类的存在，但就如‘吃饭’一样，肯定都是要的，只是具体的子类如何实现就要看子类是啥了，猫吃鱼、狗啃骨头，具体‘吃饭’的方法在子类中实现。


