封装
继承
继承中构造函数和析构函数的调用
拷贝构造函数和赋值运算符函数
名字隐藏

面向对象的三大特征
	封装/继承/多态
一/封装
	该隐藏的细节隐藏,该公开的接口公开;
		公用接口与私有实现的分离;
		类声明和成员函数定义的分离;
	作用:
	1.1便于协同开发
		如加密解密:只提供两个公开的函数
		const char *code(const char *msg);
		const char *decode(const char *msg);
	1.2防止不必要的扩展(电视机和照明煮饭的问题)
		隐藏的用private修饰;
		公开的用public修饰;
二/继承
	2.1目的
		传承:数据的复用;
		扩展:增加数据;
	//练习:定义一个Animal类
		特征:
			string name;
			int age;
		功能:
			void show(){}
		定义一个Dog类,继承Animal类型,扩展出一个功能;
			void fun(){}

	继承是一种 is a	//Dog is an Animal;
	组合是一种 has a//汽车 has a 发动机
					//汽车 has a 收音机
	2.2继承
		父类(基类)   子类(派生类)
		class B:public A{//A是父类,B是子类
		}
	2.3继承方式
		public	//公开继承
		protected//保护继承
		private //私有继承//默认的继承方式
	2.4公开继承中 父类数据到子类之后的权限变化
	父类中的公开成员到子类中是//公开的;
	父类中的保护成员到子类中是//保护的;
	父类中的私有成员到子类中是//隐藏的;//权限的隐藏,无法访问

	如何在类外访问私有或保护的数据?
		1.提供公开的访问接口,要求必须在类内可见才可以做公开接口;
		2.使用友元函数;
	2.5保护继承中父类到子类之后的权限变化
	父类中的公开成员到子类中是//保护的;
	父类中的保护成员到子类中是//保护的;
	父类中的私有成员到子类中是//隐藏的;
		
	2.6私有继承中父类到子类之后的权限变化
	父类中的公开成员到子类中是//私有的;
	父类中的保护成员到子类中是//私有的;
	父类中的私有成员到子类中是//隐藏的;

	所谓继承方式,就是父类数据给子类的最大访问权限;
	子类不会扩展父类的数据权限;

三/继承中构造函数和析构函数的调用
	构建子类对象时会先调用父类构造再调用子类构造;
	析构函数的调用顺序和构造函数的相反;
	子类构建时必须/必然会先调用父类构造,不调用父类构造就无法产生子类对象,无论是默认还是显式调用父类构造;
	子类会默认调用父类的无参构造和析构;如果基类只有带参的构造,则子类无法调用到父类的默认构造而无法创建子类对象;
	子类不一定要显式的调用父类的无参构造函数;
	子类如果需要调用父类的有参构造或析构,可以显式调用,需要在子类的构造和析构初始化参数列表指定;

四/拷贝构造函数和赋值运算符函数
	子类不会继承父类的构造函数/析构函数/拷贝构造和赋值运算符;但可以调用他们;
	赋值运算符函数在子类中调用时加 父类名::operator=
	对于析构和赋值构造,如果子类没有定义则会默认调用父类的,如果子类有自定义则默认调用自己的,如需调用父类的,要用特殊方式;

五/名字隐藏
	子类中如果定义了和父类相同名字的数据,则会把父类数据隐藏掉;
	需要加类型名和作用域才能访问到父类中的数据;
	
