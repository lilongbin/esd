IIC驱动




回顾:
linux内核input子系统:
1.旧式注册字符设备驱动的方法
  register_chrdev
  unregister_chrdev
2.input子系统:
  2.1管理的设备对象:按键,触摸屏,鼠标
  2.2为什么要使用input子系统框架来实现按键驱动的第三版本
     第一版按键驱动:轮询
     第二版按键驱动:中断+等待队列机制
  2.3第三版按键驱动只是第二版本按键的驱动的一个强化版本

  必须包含:
	1.注册字符设备:
		第二版本由设备驱动来实现
		第三版本由input核心层来实现
			evdev_fops:
				open,read,write,ioctl,poll
	2.硬件相关信息:
		第二版,第三版本都是由设备驱动实现
			GPIO资源,中断资源,中断处理函数
	3.中断触发以后,表明有效的数据到来,但是软件部分由内核核心层实现,只需在中断处理函数中(设备驱动程序中)通过input_event将硬件有效的数据(按键值,按键状态,坐标值,压力值)发送给核心层实现的软件部分,最终提交给应用程序,但是应用程序的方式通过struct input_event;
	4.通过1,2,3分析对于一个底层设备驱动程序,只需关注硬件信息即可,通过strcut input_dev来描述操作的硬件信息,通过input_register_device将硬件信息提交给核心层去使用!
	5.struct input_dev使用:
		5.1.分配input_allocate_device
		5.2.初始化
			evbit
			keybit
			absbit
		5.3.注册input_reigster_device
		5.4.注册中断处理函数
			input_event上报	

----------------------------------------------------------

按键去抖动:
	硬件去抖动
	软件去抖动
----------------------------------------------------------

+---------+
| I2C驱动 |
+---------+
串行	一根数据线,一个时钟周期传输一位;成本低,适合远距离传输,速度慢;
并行传输	8跟数据线,一个时钟周期传输1个字节;成本高,适合近距离传输,速度快;

1. I2C总线的定义
Inter-Intergrated
Circuit总线是一种由PHILIPS公司开发的两线式串行总线,用于连接微控制器及其外围设备;
	两线:两个信号线
	串行:一个时钟周期传输一个bit位
	可以挂接多个设备
        总线:CPU可用通过总线访问很多设备,多个设备可用挂接在通过一个总线上
2. 特点
I2C总线最主要的优点是其简单性和有效性;由于接口直接接在组件上,因此I2C总线占用的空间非常小,减少了电路板的空间和芯片管脚的数量,降低了互联成本;
具备多主机系统所需的包括总线总裁和高低速器件同步功能的高性能串行总线;
I2C总线只有两根双向信号线;一根是数据线SDA,一根是时钟线SCL;
	1.I2C总线可以挂接很多外设
	2.CPU通过总线可用访问其中任何一个设备
	3.I2C总线还可以挂接多个CPU
	4.多个CPU进行访问同一个外设时,I2C总线能够实现仲裁
3. 硬件特性
  主设备,主端/master:CPU
  从设备,从端/slave:外设
  SDA:数据线,用于传输数据,CPU和外设都可以进行控制;CPU向外设发送数据时,数据线由CPU控制;CPU从外设读取数据时,数据线由外设控制;
  SCL:时钟信号线,控制数据传输,时钟始终由CPU来发;
  SDA,SCL:会接上拉电阻,所以两个信号线,CPU和外设都不控制时,默认的电平是高电平;由上拉电阻控制;
  SDA信号线每次传输的数据单位为1字节;

问:CPU如何通过I2C总线找到要访问的设备的
问:SDA和SCL之间如何搭配的
问:CPU和外设之间的交互是如何通过I2C总线进行的
答:
	答案在I2C总线协议中
START:起始信号,表明开始访问设备,此信号由主设备CPU发起.
    SCL为高电平时,SDA由高向低跳变,产生START信号!

STOP:结束信号,表明此次的数据访问结束,此信号还是由主设备CPU发起;
    SCL为高电平时,SDA由低向高跳变,产生STOP信号!

SCL与SDA在不工作时都是高电平,开始和结束时都是由SDA的变化引起;

设备地址
	它用于CPU访问某一个从设备,设备地址对于外设具有唯一性,一个外设只有一个唯一的设备地址,设备地址由芯片厂家和硬件电路来指定,一旦指定好以后,CPU发送设备地址,就是表明要访问某个具体的从设备!
	常用的IIC接口通用器件的设备地址由种类型号及寻址码组成,共7位;
	D7 D6 D5 D4 D3 D2 D1
	器件类型由D7-D4共4位决定,这是由半导体公司生产时就已固定此类型了,也就是说这4位已是固定的;
	用户自定义地址码D3-D1共3位,根据硬件的接线情况确定;
	最低1位是R/W位,0表示写,1表示读;

AT24C02外设的设备地址:
   1010 A2A1A0R/W => 设备地址不算读写位,再右移1位
=> 0101 0000(假设A2,A1,A0都接地)
=> 0x50
在一个总线上该类器件最多可以接8个,通过A2,A1,A0来区分;

LM77温度传感器外设的设备地址:
The complete slave address is
1 0 0 1 0 A1 A0 其中A1,A0对应器件的6,7管脚;
1001000=> 01001000=> 0x48
同一个总线上最多可以接4个该类型的器件;

ADP8860背光芯片的设备地址:
default I2C address is 0101010x (x = 0 during write, x = 1 during read).
0101010x=> 不算X位,再右移1位 => 00101010 => 0x2a

读设备地址 = 设备地址 << 1 | 1
写设备地址 = 设备地址 << 1 | 0

ACK信号:应答信号,表示外设是否正常或者读写过程是否正常,低电平有效!

读写访问过程:
I2C从设备访问过程:
	1.CPU发送START信号,开始数据的访问
	2.CPU发送设备地址
	3.根据需求指定读,写,第8个时钟周期发送读写位:1=读,0=写
	4.设备如果正常,设备在第九个时钟周期会给CPU返回一个ACK信号
	  ACK低电平有效,如果CPU在第九个时钟周期没有检测到这个ACK
	  信号,表明设备有可能异常;
	5.根据读写实现数据交互(根据芯片手册的要求来做!)
	6.数据交互完毕以后,CPU发送STOP信号,结束数据的访问!

总结:CPU访问I2C外设的过程一定要看I2C外设的芯片手册!

问:SCL和SDA如何搭配使用
答:
	SDA数据线上的数据在SCL为高电平时,保持稳定
    SDA数据线上的数据在SCL为低电平时,可以进行修改

注意:如果程序自己实现I2C操作的时序(GPIO模拟),效率不高;还好现代的很多CPU内部自带I2C控制器,I2C控制器用来帮我们发起I2C操作的相关时序,I2C控制器的操作通过寄存器来进行!

----------------------------------------------------------
linux内核I2C驱动实现:
第1种实现方法:编写字符设备驱动,通过访问I2C控制器,来实现对I2C外设的访问.
第2种实现方法:编写字符设备驱动,通过GPIO模拟I2C时序,来实现对I2C设备的访问.
第3种实现方法:利用内核已有的I2C驱动框架,来实现I2C的驱动程序,完成对外设的访问.

第三种I2C驱动框架实现:
包含两类驱动
1. I2C总线驱动
	管理和驱动的设备对象就是I2C硬件控制器,这个驱动仅负责启动I2C控制器发起时序,至于传输的数据由I2C设备驱动来提供(I2C设备地址,读写的地址和数据).
	总线驱动一般都是由官方提供写好,只需配置添加支持即可:
	make menuconfig
	Device Drivers->
		I2C Supports->
			I2C hardware bus supports
				<*>S3C2410 I2C driver
2. I2C设备驱动
	管理和驱动的设备对象就是I2C的外设,这个驱动仅仅只负责获取数据,关心数据的具体含义,它知道这个数据的意义(设备地址,地址,数据),最终这些数据信息都会丢给I2C总线驱动来实现硬件的传输. 所以I2C设备驱动不用关心数据如何通过I2C总线传输.
	传输靠I2C总线驱动来做,但传输的数据来自I2C设备驱动.
	由于外设的种类很多,所以I2C设备驱动是I2C驱动开发的重点!

linux内核I2C驱动框架分层:
=============================================
app:open,read,write...//eeproom,lm77,adp8860
    unsigned char data = 0x20;
    unsigned char addr = 0x10;
    buf[0] = data;
    buf[1] = addr;
    write(fd, buf, 2);
----------------------------------------------
	I2C设备驱动
	eeprom_open,eeprom_read,eeprom_write:
	关心应用程序操作的数据含义:addr就是个地址,data就是个数据
	不关心数据如何传输,传输靠I2C总线驱动
----------------------------------------------
	内核提供统一的操作接口:
		i2c_transfer() /* 旧式接口 */
		SMBUS接口; /* 新式接口,能够兼容老式接口,内核鼓励使用这个接口 */
	目的:实现I2C设备驱动和I2C总线驱动的交互
	这些接口都是给I2C设备驱动来使用的,I2C设备驱动根据这些接口将数据传送给I2C总线驱动,或者从I2C总线驱动获取数据;
----------------------------------------------
	i2c总线驱动
	目的:一旦获取到I2C设备驱动的读写请求,启动I2C硬件控制器发起硬件时序,完成数据的硬件传输;
----------------------------------------------
	I2C控制器  <=> I2C外设
=============================================

问:如何实现一个I2C外设的设备驱动
答:I2C设备驱动实现也是采用设备-总线-驱动模型:
	1.内核已经帮我们定义好了一个I2C的虚拟总线i2c_bus_type,这个仅仅适用于I2C接口的外设;而platform_bus_type适合于任何设备,虽然实现的方式不一样,但目的都是为了实现分离思想;
	2.I2C的虚拟总线维护着两个链表:dev链表和drv链表;
	3.dev链表里的每个节点存放的是I2C外设的硬件信息(设备地址), 并且dev链表里每个节点对应的数据类型是struct i2c_client;
	4.drv链表里存放的每个节点是操作I2C外设的软件信息(fops), 并且drv链表里每个节点的数据类型是strut i2c_driver;
	5.每当向dev链表里添加i2c_client硬件信息时,内核就会遍历drv链表,取出每一个节点i2c_driver跟自己匹配(通过i2c_client.name和i2c_driver.id_table.name进行比较)如果匹配成功,说明硬件找到了软件,就会调用i2c_drirver的probe函数,然后将匹配成功的i2c_client的首地址传递给probe函数,probe函数里做的事情由驱动来自己实现,比如可以注册一个字符设备;
	6.每当向drv链表中添加i2c_driver软件信息时,内核就会遍历dev链表,取出每一个节点i2c_client跟自己匹配(通过i2c_client.name和i2c_driver.id_table.name进行比较)如果匹配成功,说明软件找到了硬件,就会调用i2c_drirver的probe函数,然后将匹配成功的i2c_client的首地址传递给probe函数,probe函数里做的事情由驱动来自己实现,比如可以注册一个字符设备;

总结:实现一个I2C设备驱动程序就是围绕着i2c_client和i2c_driver;

问:这两个结构体如何使用,怎么实现软硬件分离然后再结合
答:
首先
i2c_client的分配,初始化,注册都要依赖另一个结构体:	struct i2c_board_info
通过对i2c_board_info的分配,初始化和注册,间接地实现对i2c_client的分配,初始化和注册;

所以对i2c_client的研究最后转换为i2c_board_info的实现过程:
必须在平台代码中进行分配,初始化和注册,实现过程如下:
1.进入内核源码并打开平台代码
	$ vim arch/arm/mach-s5pv210/mach-cw210.c
2.在平台代码的开始处,添加以下代码(实现分配,初始化 i2c_board_info):
static struct i2c_board_info at24c02[] = {
	{
		I2C_BOARD_INFO("at24c02", 0x50),
		/* "at24c02"最终将赋值给i2c_client的成员name,很重要; */
		/* 0x50就是设备地址,最终将赋值给i2c_client.addr */
		/* 设备地址需要查看硬件手册确定, 二进制**** ***x转化为16进制 */
		.platform_data = 自己定义的硬件私有结构体指针(类似platform_device.dev.platform_data)
	
	}
};

3.在平台代码的初始化函数中(.init_machine = smdkc110_machine_init)调用i2c_register_board_info()注册分配初始化好的i2c_board_info;
	i2c_register_board_info(0, at24c02, ARRAY_SIZE(at24c02));
	/* 0是总线编号,这个值的确定要根据我们的i2c外设接到CPU的哪个总线上(通过参看原理图可知) */
4.make zImage,用新内核重新引导即可;
5.通过在平台代码中完成对i2c_board_info的分配,初始化和注册,内核每当初始化时,都会先将i2c_board_info注册到内核中指定的一个链表中,i2c总线驱动会遍历链表,取出每一个i2c_board_info信息,然后总线驱动根据i2c_board_info中的设备地址信息,操作I2C控制器发送设备地址,如果设备正常,会返回给I2C总线驱动一个ACK信号,内核就会帮我们实例化一个i2c_client,然后将i2c_board_info中初始化的信息全盘赋值给i2c_client然后帮我们实现注册过程;

其次
i2c_driver的使用(软件信息):
1.分配i2c_driver
2.初始化i2c_driver
	.probe = at24c02_probe, /* i2c_client和i2c_driver匹配成功以后执行,并且i2c_client的指针会传递给probe函数 */
	.remove = at24c02_remove, /* 卸载时调用 */
	.id_table = at24c02_id /* 要添加的.name要和i2c_board_info.name一致,匹配的参照 */
3.调用i2c_add_driver()注册i2c_driver
	3.1.添加i2c_driver节点到drv链表中
	3.2.遍历dev链表,取出已经注册的i2c_client信息,然后进行匹配(i2c_client.name和i2c_driver.id_table.name),匹配成功则调用probe函数;

案例:实现at24c02的设备驱动:at24c02_drv.c


