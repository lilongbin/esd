misc混杂设备驱动




回顾:
1.按键去抖动
  硬件去抖动
  软件去抖动
     方法1:通过延时(忙等待)
     方法2:定时器去抖动
2.I2C相关内容:
  1.I2C的应用领域
    手机:摄像头,音频,各种传感器,触摸屏
  2.I2C:两线式串行总线
  3.硬件特点:SDA,SCL,上拉电阻(默认高电平)
    I2C外设都可以接到同一个总线上,CPU通过I2C总线来访问外设
  4.I2C传输协议:
    START
    STOP
    设备地址:看芯片手册
    读写位
    ACK:低电平 
    读写数据过程要参看芯片手册的时序图
    SCL和SDA的配合问题
    100KHz
    400KHz
    3.4MHz
 5.linux内核I2C的驱动实现过程
   框架:
   app:open,read,write...
   ./at24c02_test w addr data
   ./at24c02_test w 0x10 0x10
   ./at24c02_test r 0x10
   -------------------------
       I2C设备驱动层:
       不关心数据是如何传输的,数据传输通过I2C总线驱动来实现
       关心数据的特点含义
------------------------------
        i2c_transfer
        SMBUS
        I2C设备驱动层通过这两个接口将用户的数据丢给
        I2C总线驱动,最终完成数据的硬件交互
------------------------------
       I2C总线驱动层:
       控制I2C控制器,完成总线的硬件传输
       传输数据来自I2C设备驱动层

6.i2c设备驱动程序实现:
  分离思想->设备-总线-驱动模型
  i2c_client:I2C外设的硬件信息(设备地址)
	依赖:i2c_board_info(在平台代码中:分配,初始化,注册)
  i2c_driver:I21C外设的操作软件信息(fops)	

案例:实现对EEPROM(at24c02(0~255))的读写访问
测试:
   ./at24c02_test w addr data
   ./at24c02_test w 0x10 0x10
   ./at24c02_test r addr
   ./at24c02_test r 0x10

案例:将软件和硬件版本号写入EEPROM存储并且能够读取版本信息
版本号格式如下:
软件版本号:SYYMMDDXY,例如:S14051600
硬件版本号:HYYMMDDXY, 例如:H14051602
切记:要注意对EEPROM存储进行划分
软件版本号:0~0x10
硬件版本号:0x10~0x30

项目提升:将寄存器编辑器->设备操作维护软件

+------------------+
| misc混杂设备驱动 |
+------------------+
1.定义:非标准的字符设备就是混杂设备,其实混杂设备还是字符设备,只是主设备已经由内核定义好为10,通过此设备号来分区各个混杂设备个体
2.数据类型
  struct miscdevice {
	int minor; //次设备号,如果指定宏MISC_DYNAMIC_MINOR,表明让内核帮你分配一个次设备号
        char *name; //设备节点名,设备节点由内核创建
	struct file_operations *fops; //给应用程序提供的访问操作接口
  };
3.实现一个混杂设备驱动:
  1.分配,初始化miscdevice
    struct miscdevice led_misc = {
	.minor = MISC_DYNAMIC_MINOR,
        .name = "myled", //dev/myled
 	.fops = &led_fops
    };
 2.调用misc_register向内核注册即可
   卸载misc_deregister即可

案例:利用混杂设备驱动框架实现LED驱动
----------------------------------------------------------
AD/DA:
模拟信号:连续的信号,声音,电压,温度等
数字信号:离散信号,0,1表示的信号信息

A/D:模拟信号转成数字信号的过程
D/A:数字信号转成模拟信号的过程

手机录音,放音:
录音:模拟信号转成数字信号的过程
放音:数字信号转成模拟信号的过程

ADC/DAC:
ADC:模拟信号转换为数字信号的硬件单元
DAC:数字信号转换为模拟信号的硬件单元

手机中使用audio codec 音频处理芯片:集成了ADC和DAC

衡量ADC的工作参数指标:
1.分辨率
  描述ADC转换的最小量度. 一般ADC的分辨率有8,10,12,20,24位等. 
  例如:对于一个电压模拟信号,测量电压为3.3V,电压变化范围为0~3.3.如果采用ADC对其进行转换,并且ADC使用的转换的分辨率为10位(表示的是转换以后的数字量是一个10位的有效值). 也就是说3.3V模拟量对应的数字量就是1111111111(二进制),从而得到最小量度:3.3/1024 = 0.0032,如果采用的分辨率为12位,最小量度:3.3/4096 = 0.0008.3.3V电压对应的数字量就是111111111111.
如果已知一个数字量是0010110111(10位),请问对应的模拟量是多少?3.3/1024 * (0010110111).
  
2.转换时间:一般分辨率越高,转换的时间就会越长,但精度比较高!
----------------------------------------------------------
ADC硬件电路设计问题:
1.现在很多CPU都自带ADC,在硬件电路设计时,如果采用自带ADC,最后涉及的驱动程序,就是简单的字符设备驱动,通过操作ADC相关的寄存器达到对ADC的控制和访问
2.如果不适用CPU自带的ADC,使用外置的ADC芯片,切记要考虑外置ADC芯片和CPU之间的通信接口,因为这种接口直接影响驱动的涉及,比如如果采用I2C接口的,外置ADC芯片驱动就是I2C设备驱动,如果GPIO类型的接口,外置的ADC芯片驱动就是普通的操作GPIO来驱动ADC. 

对于S5PV210来说,使用的是自己的ADC:
硬件特点:
1.分辨率:10位和12位
2.ADC转换器只有一个,但是模拟信号输入通道有10路
3.ADC最大的工作时钟频率5MHz,ADC的时钟源是PCLK=66MHz,注意要降频
4.ADC只能转换电压模拟信号,电压信号的范围是0~3.3V
5.在同一时刻,ADC只能处理一路模拟输入信号,可用通过操作内部的多路选择器来指定转换哪路模拟输入通道
6.AIN0,AIN1两路只能接入普通的模拟输入信号,不能外界触摸屏
  AIN2~AIN9这八路即可用于普通的ADC转换,也可以用于触摸屏
7.由于ADC转换需要时间,速度相对CPU来说,会慢点,所以一旦ADC转换结束,会产生一个内部中断,告诉CPU,转换结束. 
8.10路模拟输入通道,只能用于输入,不能复用!
9.使用涉及的寄存器:
  控制器寄存器
	配置分辨率
  	配置时钟频率
	启动ADC的转换
  延时寄存器
  数据寄存器
	保存的转换以后的数字量 
	data = 寄存器 & 0xfff //12
    data  = 寄存器 & 0x3ff //10
  中断清除寄存器:采用中断方式
  模拟输入通道选择寄存器
10.判断ADC转换结束的方法:
   1.轮训读取控制寄存器的第15bit
   2.通过中断,如果中断触发,表明ADC转换结束

驱动程序设计:
1.注册混杂驱动
  read:获取转换以后的电压,如果没有转换结束,应该进入休眠
  ioctl:配置分辨率,配置模拟输入通道
2.注册中断处理函数
	唤醒休眠的进程
	清中断
3.地址映射
4.初始化设置ADC处于一个正常的工作模式
  设置默认的分辨率
  设置默认的工作频率
  设置默认的模拟输入通道
readb/readw/readl
地址中的内容 = readx(内核虚拟地址);

writeb/writew/writel
writex(要写入的值,内核虚拟地址);

测试步骤:
./adc_test 12 1

项目提升:设备操作维护软件:每隔5s上位机QT界面显示ADC的采样电压



