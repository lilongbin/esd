回顾:
    异常处理程序
    1/异常处理程序中每种异常都有一个
       入口:
       异常向量表中,每种异常占用几个字节?
       四个字节
    2/异常向量表中放哪些指令?
       ARM 的跳转指令
    3/我们使用的CPU是什么CPU?
       S5PV210
       S5PV210 处理器的核心是什么?
        ARM Cortex-A8
    4/对于S5PV210处理器来说,它的异常向量
       表在什么地址?
       地址0
    5/当处理器上电以后,S5PV210处理器
       到什么地址取指令执行?
       复位异常入口,地址0
       在这种情况下,CPU取得的指令(IROM程
       序),上电以后地址0对应的IROM;
       通过地址0访问的是三星写了一个异
       常处理程序;

    6/为了在发生异常时,s5pv210能执行我的
       异常处理程序,该怎么办?
       我们就希望s5pv210访问地址0的时候
       能访问到我们的代码;
       如果地址0处可以写,就可以把异常向量
       表放到地址0
       但是这个处理器,物理地址0不能写;
       这种情况下,我们使用MMU完成什么?
       当CPU访问地址0时,MMU将地址变换到
       0x20000000,我们把我们的异常向量表
       放到物理地址0x20000000;
    7/虚拟地址和物理地址的对应关系由谁
       来决定的?
       由我们开发者,我们开发者告诉硬件
      (MMU)虚拟地址和物理地址的对应关系;
    8/SWI异常的响应过程?
       软件层面执行 swi 1或者swi 2
       硬件发生软中断异常,s5pv210就
       到地址0x8取指执行
       地址8是我们放的一条跳转指令
       会跳到我们编写的软中断异常处理程序
       我们的软中断处理程序会取得swi指令后面
       跟的号 1 或者2
       然后根据号来执行不同的功能
       如:如果号是1 执行LED 亮
           如果号是2 执行LED 灭;
   9/同理,你能不能思考一下FIQ或者IRQ的
      异常响应过程?
      当软件执行的时候,来了一个FIQ或者
      IRQ中断信号;
      如果此时,FIQ或者IRQ是开启的,处理器
      开始响应异常;
      如果是IRQ,cpu将到0x18地址取指执行
      0x18处放的跳转指令,跳转到我们的
      irq异常处理程序;
如何处理IRQ异常;
    中断;
案例:
    当开发板上的按键按下时,触发一个中断
    事件,处理器开始执行我们对应的中断
    处理程序;
    从表面上来看,我们能看出一个要素;
    中断源;

    1/中断源    
    中断源是按键(GPIO中断);
        我们选择UP 键来触发中断
        GPH0 0 号管脚;
        GPH0 0 号管脚怎么才能触发中断?
        通过看手册我们看到;
        1/让GPH0 0 号管脚工作在外部中断
           管脚方式 
           0xE0200C00
           GPH0CON[3:0] = 0xF
        2/根据电路图我们知道
           GPH0 0 管脚的内部上下拉电阻
           不需要了;
           GPH0PUD[1:0] = 0
        3/EXT_INT_0_CON 寄存器
           中断触发方式控制
           控制GPH0 0 管脚使用什么样的
           中断触发方式;
               低电平触发
               高电平触发
               下降沿触发
               上升沿触发
               两个边沿都触发
         ----+    +--------
             |    |
             +----+
           下降   上升
          我们现在的情况使用哪种触发方式?
             低电平触发
             下降沿触发
          建议用下降沿触发
          EXT_INT_0_CON[2:0] = 2
        4/滤波功能先禁止掉
          EXT_INT_0_FLTCON0 = 0
        5/EXT_INT_0_MASK
           EXT_INT_0_MASK[0] 
           中断屏蔽寄存器
           对应位为0 对应的中断源开启
           对应位为1 对应的中断源关闭

        6/EXT_INT_0_PEND
           EXT_INT_0_PEND[0]
           中断挂起标志
           表示的是处理需要响应
           对应的位为1表示有中断
           对应的位为0表示没有中断
           如果对应的位为1,就会打断
           CPU(中断开启,如:arm的IRQ
                开启);
           注意:
               该位在中断处理器程序
               处理完相应的事件后,需要
               清除该标志(软件清除);

               要清除相应的位,向该位写
               "1"!!!!
                         
    2/中断控制器 
       S5PV210 中断控制器把所有的中断
       分成4组
       每组有相应的寄存器.
       GPH0 0 管脚的中断,XEINT0
       在第0组,VIC0,第0号

       注意:
     When user clears interrupt pending, user must write 0 to all the VICADDRESS registers (VIC0ADDRESS, VIC1ADDRESS, VIC2ADDRESS, and VIC3ADDRESS).
      寄存器:
     1/VIC0INTSELECT
        对应的位控制的是vic0里面的中断
        走ARM核的IRQ还是FIQ        
        0---IRQ
        1---FIQ 
        VIC0INTSELECT = 0

        TZIC0IntSelect = 0

     2/VIC0INTENABLE
        开启中断:
        写1开启中断,写0无效
        读取1表示中断开启
        读取0表示中断关闭
     3/VIC0INTENCLEAR
        关闭中断
        写1关闭中断
        写0无效

     4/VIC0ADDRESS 
        当中断发生时,软件读取该寄存器
        就能得到相应的中断服务程序的地址;
        能得到中断服务程序的地址,就能调用
        相应的中断服务程序;
        
        ARM核中IRQ中断只有一个入口,不管
        外部什么设备触发IRQ中断,硬件都是
        执行IRQ异常处理程序;
      谁来区分到底是什么设备产生的中断呢?
        ARM核IRQ异常处理程序来区分(软件);
        软件怎么来区分呢?
           中断控制器需要提供相关的机制;
        
     s5pv210的向量中断控制器怎么知道
     具体的某个中断服务程序地址呢?
         没那么智能,具体中断
       服务程序的地址是我们软件告诉
       中断控制器的;
     5/VIC0VECTADDR[0-31]

   问题:
      向量中断把所有的中断源分成4组
      4*32=128,每组中有空的位置;

      每组有32个中断服务程序地址寄存器
      我们把写好的中断服务程序地址,
      设置到32个中的某个;
      中断发生后,中断控制器把对应中断
      服务函数地址复制到VIC0ADDRESS
      举例:
          我们用的GPH0 0 管脚中断
          XEINT0中断,向向量的0组第几个0
       把我们写的XEINT0的服务程序地址
       放到VIC0VECTADDR0寄存器;
       当我按键后,发生中断,中断控制器
       把VIC0VECTADDR0复制到VIC0ADDRESS
         GPH0 1 XEINT1
         VIC0VECTADDR1复制到VIC0ADDRESS

       IRQ异常处理程序里面,我只有读取
         VIC0ADDRESS就能得到发生的中断
       的中断服务程序地址;

       中断处理程序把中断处理完,需要清除
VIC0ADDRESS寄存器,0.
     When user clears interrupt pending, 
     user must write 0 to all the 
      VICADDRESS registers 
     (VIC0ADDRESS, VIC1ADDRESS, 
     VIC2ADDRESS, and VIC3ADDRESS).
   
  IRQ异常处理程序里面你需要读取VICADDRESS
  得到中断服务程序地址;
  需要读取几个寄存器?
      VIC0ADDRESS 
      VIC1ADDRESS
      VIC2ADDRESS
      VIC3ADDRESS

   TZIC0IntSelect = 0


    3/arm核中断相关
    
       异常向量表编写,并且保证cpu访问
       地址0能访问异常向量表;
      
       编写IRQ异常处理程序
          IRQ异常处理程序里面,读取
          
           VIC0ADDRESS 获得具体的中断
服务程序的地址,并调用中断服务程序;
           清除VIC0ADDRESS;

   1/要是按键能发生中断,并且处理;
      要做的工作有哪些?
      以UP键,GPH0 0 为例;
      
     配置GPH0 0 管脚中断相关内容
        使GPH0 0 管脚工作在中断模式
        禁止GPH0 0 管脚上下拉电阻
        配置GPH0 0 管脚中断触发方式
          禁止滤波
        开启/关闭GPH0 0 管脚中断
        中断挂起标志

      跟向量中断控制器相关的:
        是中断触发ARM核的IRQ;
        编写XEINT0的中断服务函数
        把中断服务程序地址告诉中断控制器
           VIC0VECTADDR0
        向量中断开启

      ARM核的中断控制
        我们需要编写IRQ的异常处理程序;
        开启和关闭ARM核的IRQ中断
             CPSR.I 0/1  
     
练习:修改代码使按向下键的,Down产生
      中断,并在中断处理程序中响应;
      XEINT0 中断发生,LED亮
      XEINT1 中断发生,LED灭


     ftp服务器上下载代码:

      arm10-boot.tar

     稍后使用;
      
     过程:
      1/up键按下,中断发生
      2/硬件到0x18取指令执行
      3/跳转到汇编写的_irq_handler
      4/_irq_handler函数里面调用了C
         语言写的IRQ处理函数
         c_irq_handler
      5/c_irq_handler我们判断是哪种
         中断发生,并调用相应的中断
         服务函数;
         从VIC0ADDRESS寄存器取出中断
         服务程序地址,调用;
         实际执行的是:exint0_func
      
S5PV210的启动过程
   仅限于S5PV210
   上电:
       1/ARM核从地址0取指执行
       2/执行的是IROM代码(BL0)
       3/IROM程序它判断从什么设备上
          读取用户代码(我们写)
          或者启动代码;
          如:USB启动;
       4/IROM程序根据OM[??]管脚状态
          来决定从什么设备上取代码
           (BL1)
          (1) IROM程序从设备上最大
              读取16K代码;
          (2) IROM程序从启动设备上读取
              代码放到IRAM(0xD0020000)
          (3) 实际读取多少由谁来定?
              软件开发者来定;
              软件开发者可以指挥IROM程序
              实际读取多少代码到IRAM;
              比如:uboot代码,就告诉
              IROM程序读取8K代码到IRAM;
        5/IROM程序读取完代码,自动执行
           这段代码(这段代码BL1,在
           IRAM中);
       我们BL1代码一般做哪些事情?
          硬件初始化
          以uboot为例:u-boot.bin有
          300多K
          IRAM只有96K

          *应该配置DRAM控制器
             让开发板上的1G内存工作
             1G可以用;
         从启动设备(如:nand flash(闪存))
         把u-boot代码读取DDR内存
         BL1程序需要跳转到DDR内中的执行;
         
   每次都是把BL1放到0xD0020000吗?
     每次都是(S5PV210);
   不同的CPU都是这样吗?
     不是
          
   IRAM地址在0xD0020000;
   IRAM---SRAM   S5PV210内部,眼睛看不见;
   1G内存-DDRII,在S5PV210的外部
                 在开发板上,8颗内存芯片
   
   USB启动方式,IROM程序运行的时候,它
   能用的内存就是IRAM(96K),地址
   0xd0020000;
   这个地址和dnw 下载x210_usb.bin地址
   0xd0020010 像;
   0xd0020010 怎么来的呢?
      其实是因为IRAM在d0020000处,
     usb启动过程中使用内存必须在
     0xd0020000开始的96K内;
     具体位置由IROM程序定;
  
  做安装程序(第一天实验)读取8K代码
  在哪里?
      在什么位置取决于启动设备;
      我们做实验的时候设备是USB
      PC通过USB向IROM程序发送;
      从PC机上来;
  
  IROM程序会从启动设备读取代码,最大读
  16K代码放大IRAM中,实际读取的大小
  由开发者定;
  IROM程序如何知道具体要读取多大?
      IROM程序定义死格式;
      IROM程序要求启动代码(BL1)
      前面要有16字节头;
      第一个字:BL1大小(包括16字节头)
      第二个字:保留0
      第三个字:checksum(不包含16字节头)
      第四个字:保留0
  checksum 校验值,是指哪些数据的校验值?
      BL1除16个字节外的数据的校验值;
  怎么算这个校验值?
      校验值的算法是IROM程序定义死的;
  
  对于不同的设备,IROM程序怎么知道到
  到哪里去读取代码(BL1)呢?
    IROM程序规定了使用不同启动设备时
    BL1的位置;
    
案例:让我们写shell能在开发板上独立运行;
   1/有硬件初始化代码
   2/加文件头
   3/烧写到nand flash 的开始;
   步骤:
      1/把给定的arm100_boot.tar解压
      把里面的文件复制到boot目录(刚
      创建的);
      2/修改makefile
         OBJS 在start.o后面添加dram.o
              删除reset.o
      3/修改shell.lds
         起始地址改为:0xd0020000
         vector.o 改为start.o
      4/修改uart.c
         uart0_init函数

     编译生成.bin
     把.bin写到nand flash的最开始;
     loadb 20008000
     
     nand erase 0x0  0x20000
     nand write 0x20008000 0x0 0x20000
    
     开机重新启动;
     shell能运行;
 
扩展作业:
    不是必须做;
    b-boot启动以后,不敲空格键,u-boot
    干什么事情?
        加载linux内核执行
    空格相当"后门"
    u-boot引导程序,本职工作是加载内核;
    后门留给谁用的?
        我们开发者;
        有写协助开发功能,比如烧写闪存;
    
    我们可以为我们的shell(引导程序)
    加入功能,不按任何键,自动加载内核;
        如果按了键(自定义,开发板上的)
        
        
      
        
     
        
      
     

 







