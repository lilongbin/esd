回顾:
    shell 
    1/if else
    2/结构体数组
    注意:代码结构
atoi
   把字符串转成整数
itoa
   把给定的整数转成字符串
   转换成16进制字符串0x????????
   void itoa(char *buf, unsigned int num);

闪存:
  一/NOR和NAND型闪存共有的特征
      1/出厂的时候(闪存干净的,没数据时)闪存里面每个单元都是1,按字节来说0xFF;
      2/写数据时,是把里面的1改成0,不能把0改成1
         0xFF  ->0xAA 
      3/如果要改写,先使用专门的擦除命令,把闪存中的内容擦掉(0-->1) 0xFF
      4/擦除是有单位的,通常我们称之为块(Block),不同的闪存块大小不一样;
      5/块本身有寿命,擦写次数有限制,不同闪存的块寿命不一样;
      6/写入数据,需要专门的写入命令(看闪存手册)
      7/闪存读写数据时,有可能发生位反转(位交换)错误;
         0  1
      8/使用的时候就需要使用错误纠正算法,来保证数据的可靠性;
         ECC算法
  二/NOR和NAND型闪存区别
      闪存会有坏块,nand 出厂时就可能有坏块
      nor 型出厂时一定没有坏块
  三/思考
      当使用nand闪存时需要考虑哪些问题?
      1/坏块,软件要考虑坏块管理;
         坏块就写数据,没必要读坏块数据;不擦除,不写入;
      2/重写时要先擦除;
      3/nand flash发生位交换的错误概率高,需要使用ECC算法纠正错误;
      4/每个块有寿命,不能总擦写某一个块;
         注意:擦写均衡,写均衡;
         尽可能让所有的好块有平均擦写机会;
 nand flash 分为:
  SLC 型    1bit ECC校验就可以了
            闪存,可靠性好,成本高
   
  MLC 型    4/8/12/16/24/40/60..
            bit ECC,具体要看闪存
            MLC用的比较多;
            必须使用ECC
            容易发生位交换,但是通过使用高性能的ECC算法可以保证数据可靠性;
            容量大,便宜;

     
yaffs/yaffs2 文件系统
  OOB

我们用nand flash是K9K8G08U0B
	1	Page		= (2K + 64)Byte
	1	Block		=	64pages
	1 Device	= 8192 Block
1/读取/写入以页为单位;页大小是2K+ 64 Byte
2/擦除是以块为单位, 块大小是 64 页
3/整个设备有多少块 8192块
4/访问nand flash给出地址
   每个周期给出8位(IO只有8位)
   先给出页内偏移,再给出页号的方式
   具体来说:
   1周期  页内偏移的低8位
   2周期  页内偏移剩余的4位,IO高4位为0
   3周期  给出页号的低8位
   4周期  给出页号的8-15位
   5周期  给出页号的16,17,18位;IO剩余的位为0
5/出厂时就有可能有坏块
   如何检测一个块是好的还是坏的?
   通过每块的第一或者第二页的2048位置的数据是否为0xFF来判断
   如果每块前两个页的2048位置都是0xFF为好块,否则为坏块;
  
   注意:不要去擦除坏块;
        有可能坏块标记擦没;

  S5PV210处理器的nand flash控制器
我们需要看的寄存器:
NFCONF  0xB0E00000
NFCONF = (0xF<<12) | (0xF<<8) | (0xF<<4)| (1<<1)

TACLS = ALE/CLE由低到高---nWE由高到低时间
      = 闪存的
      = Tcls  - Twp
      = 12ns - 12ns
      = 0
      
TWRPH0 = nWE低电平持续时间
       = 闪存中
       = Twp
       = 12ns

TWRPH1 = nWE有低到高----ALE/CLE由高到低
       = 闪存中是 Tclh
       = 5ns

NFCONT  0xB0E00004
   = (3<<22) | (3<<4) | 7

NFCMMD  0xB0E00008
   把需要发给闪存的命令写入到命令寄存器,即完成向闪存发送命令
NFADDR  0xB0E0000C
   把地址写入到地址寄存器,就完成了向闪存写地址;

NFDATA  0xB0E00010
   读取和写入,就可以获得或向闪存写入数据

NFSTAT  0xB0E00028
    BIT4 
      当RnB管脚发生由低到高的变化时,这位自动设置成1,如果要清除该位,需要向该位写1
      也说明:这个位需要手动清除;
      
  
