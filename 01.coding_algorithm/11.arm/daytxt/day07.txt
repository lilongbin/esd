ARM的状态:ARM状态,THUMB状态
   ARM状态,只执行ARM指令
   ARM指令是32位,4个字节;
   ARM指令在内存中地址应该是4的倍数
   PC的值表示取指的地址;
     (指令的地址)
   PC的值就是4的倍数
      按照4个字节对齐
      4%4=0
      5%4=1
      6%4=2
      7%4=3
      100  
       01
       10
       11
   THUMB状态,只执行THUMB指令
   THUMB指令是16位,2个字节;
   THUMB指令在内存中地址应该是2的倍数
   PC的值表示取指的地址;
     (指令的地址)
   PC的值就是2的倍数
      按照2个字节对齐
      PC寄存器的值的特点就是最低1位是0
寄存器:
   add  r0, r1, r2
   add  r12, r14, r15

      r0=r1+r2
   ADD  R0, R1, R2

用户模式可以使用的寄存器
     R0-R15, CPSR (当前程序状态寄存器)
系统模式使用的寄存器和用户模式相同

IRQ模式
     R0-R15   CPSR,SPSR(为了保存CPSR)
     R13,R14,SPSR 该模式专有
FIQ模式
     R0-R15, CPSR,SPSR
     专有
     R8-R12
     R13,R14,SPSR
UNDEF模式
     R0-R15, CPSR,SPSR
     专有:R13,R14,SPSR
SVC模式:
     R0-R15, CPSR,SPSR
     专有:R13,R14,SPSR
ABORT模式:
     R0-R15, CPSR,SPSR
     专有:R13,R14,SPSR

特殊功能的寄存器:
   R13  SP   通常是栈顶指针寄存器
      ARM处理器里面有6个R13,其实可以做到每种模式有自己的栈空间
      用户模式和系统模式共用一个栈
       +----------------------------+
       |栈                          |
       +----------------------------+
       |堆                          |
       +----------------------------+
       | BSS段(没有初值或者初值为0 |
       +----------------------------+
       |  数据段(有初值的全局变量)|
       +----------------------------+
       | 代码和只读数据             |
       +----------------------------+

   R14  LR  用作返回地址寄存器
      当调用子程序的时候,把调用指令的下一条指令的地址放到R14(lr)寄存器中,该过程由硬件自动完成;子函数执行完毕,需要返回到调用指令的下一条指令继续执行;
      在子函数当中就可以根据R14(lr)寄存器获得子函数的返回地址;
      bl  func1
      add r0, r1, r2
      硬件自动完成!!!
      add r0,r1,r2
      sub r0,r1,r2
      还有一种情况:
        当发生异常的时候,硬件需要让软件跳转到异常处理程序,当异常处理程序执行完毕之后,需要返回到处理异常的下一条指令继续执行;      
        异常处理程序怎么知道返回到哪去?
        当发生异常时,硬件自动把"返回地址"放到R14(lr);
      R14,LR可以叫做返回地址寄存器
      硬件自动修改(自动保存)
      1/子函数调用指令(bl)
      2/异常发生时  

func1:
    mov pc, lr
      
     R15,PC 寄存器,就是用来保存取指地址的,硬件自动使用;
      当修改R15(PC)值会带来什么后果?
         跳转 
      修改有注意事项:
         ARM状态:修改PC(R15)应该注意给的值是4的倍数
         THUMB状态:修改PC(R15)应该注意给的值是2的倍数      
CPSR是当前程序状态寄存器
SPSR是CPSR的备份寄存器
    将来可以把CPSR的值放到SPSR中,也可以从SPSR中恢复CPSR的值;
    当异常发生时,硬件想修改CPSR,修改之前硬件把CPSR的值保存到SPSR中进行备份;
    CPSR和SPSR中各个位的含义一样;

比较一下IRQ和FIQ
  FIQ叫快速中断
  IRQ叫中断
     快的含义是什么?
         响应的快!!
  FIQ比IRQ响应的快,体现3个方面:
    1/FIQ的优先级比IRQ高
    2/FIQ模式专有寄存器多(比IRQ模式)
       R8-R12
    3/在异常向量表中,FIQ入口在向量表的最高地址;       

以上寄存器也可以当做普通寄存器使用;
    add  r0, r15, #8
    sub  r0, r13, #8
    add  r14, r1, r2
    
    swi 20

异常:
    有几种异常?
    七种:复位,未定义,软中断,指令预取,数据异常,中断,快速中断
    每种异常都有一个入口,把7种异常的入口地址放到一起,我们称为异常向量表;
    在异常向量表中,每种异常占4个字节;默认情况下,异常向量表放到地址0
当异常发生时,硬件做哪些工作?
  把CPSR保存到SPSR(即将进入模式的)
  修改CPSR(包括:模式位,状态位)
      模式位怎么修改?
          进入到与发生异常对应的模式
      状态怎么修改?
          进入到ARM状态
  保存返回地址到LR(R14)
  修改PC值为异常入口地址(比如IRQ,0x18)
软件异常处理程序返回时,至少要做:
  由SPSR恢复CPSR
  由LR恢复PC
  
  在异常向量表中能放什么指令?
      ARM的跳转指令!对!
  为什么是要放ARM的跳转指令?
      当执行指令的时候,硬件已经处于ARM状态(发生异常时,硬件自动进入到ARM状态)
      为什么放的是跳转指令?
      每个异常的入口,在向量表中只有4个字节的空间,无法放下所有的异常处理代码,所以异常向量表中,我们放一个ARM的跳转指令,跳到真正的异常处理程序;
异常和模式的对应关系是什么?

复位异常----管理模式-----R0-R15,CPSR,SPSR
未定义异常---未定义模式--R0-R15,CPSR,SPSR
软中断异常---管理模式----R0-R15,CPSR,SPSR
指令预取异常----中止模式-R0-R15,CPSR,SPSR 
数据异常--------中止模式-R0-R15,CPSR,SPSR
中断异常--------中断模式-R0-R15,CPSR,SPSR
快速中断异常----快速中断模式-R0-R15,CPSR,SPSR

异常和状态的关系?
   发生异常时,处理器自动进入ARM状态;

为什么用户模式和系统模式没有SPSR寄存器?
  因为用户模式和系统模式是非异常模式
  没有一个事件使cpu能进入到这种模式
  也就不需要CPU自动保存CPSR;
  所以这两种模式没有SPSR;

指令:
   *分支指令
   *数据处理指令
   *加载/存储指令
     加载:把存储器的值读取到寄存器(R0)
     存储:把寄存器(R0)值保存内存中
   
   了解:状态寄存器访问指令
         软中断指令
         协处理器指令 (认识)
B指令:
   B{条件}  标号
   
   B指令的跳转范围是PC=PC+/-32M

   B指令是绝对跳转还是相对跳转?
      相对!!!

   相对跳转是动态,只有程序运行起来
   我们才能确定跳转的具体地址;   

start:
   mov  r0, #0
   b   start
   adds  r0, r1, r2
   beq start
BL 指令:
   ARM汇编子函数调用指令
   BL{条件}  标号

   bl   strcmp
   bleq strcpy
   blne memset
   注意的问题:
   1/当执行BL指令时,硬件自动把BL指令的下一条指令的地址存LR(R14)寄存器中;
   2/子函数如何返回呢?
      只要把LR复制到PC,就可以实现函数返回;
   3/相对跳转
   
BX指令是带状态切换的跳转指令
   BX{条件}  Rm

   BX   R0
   如何确定跳转完切换到什么状态呢?
     Rm寄存器的最低位是0/1决定的;
     Rm BIT0是1,跳转完之后切换到THUMB状态
     Rm BIT0是0,跳转完之后切换到ARM状态
         
   MOV  R0, #0x20000000
   BX   R0
        跳转到0x20000000地址,同时切换到
        ARM状态;
        0x20000000地址应该存放什么代码?
          应该放ARM代码;

   MOV  R0, #0x20000000
   ADD  R0, R0, #1
   BX   R0       
        跳转到0x20000000地址,同时切换到
        THUMB状态;
        跳转到0x20000000地址!!!!
        0x20000000应该放什么指令?
            放thumb指令;
        最低位的值1并不参与跳转地址的计算;
        仅仅用来表示切换到什么状态!
 
    CPSR.T = RM的第0位
    PC=Rm & 0xFFFFFFFE
  
虚拟机软件
qemu软件
  vmware 
  qemu用做arm虚拟机
  arm-linux-gdb   用arm-linux-gcc 4.4.1

  gdb 调试

  把qemu.rar解压到共享目录(win,bunutu)
  在ubuntu下面进入到qemu安装包所在的目录
  sudo dpkg -i *

编写汇编源文件bl.s
-------------------------------------------
  .text
  .code 32
  .global main
main:
    stmfd   sp!, {lr}   @把lr入栈
    bl          func1   
    ldmfd   sp!, {pc}   @把入栈lr出给pc
                        @返回到调用main
func1:
    bl        func2
    mov   pc,  lr
func2:
    mov   pc,  lr
    .end
-------------------------------------------
1.bl.s汇编.o文件
  $arm-linux-as -g -o bl.o bl.s
2.把bl.o连接成可执行文件
  $arm-linux-ld -o bl bl.o  -e main
  bl可执行文件生成
   
3.在当前终端窗口T1中按Ctrl+Shift+T 再开一个终端窗口T2,都进入到bl程序所在目录
  在T2窗口执行qemu命令:
  	$qemu-arm  -g 1234 bl
  	使用qemu-arm执行 bl程序
  	-g 1234
  	qemu 运行程序他会监控端口1234
  	等待gdb的连接;
  	本窗口的qemu将不退出,等待;
  在T2窗口执行gdb
   	$arm-linux-gdb bl
  	用gdb调试程序
  	gdb启动以后,在gdb命令行下设置目标:
	   target  remote  localhost:1234
	   看到将要执行的下一条指令
	   s      命令执行程序
	   info r 命令查看寄存器的值;
	   q命令,退出gdb

   BL 指令执行的时候,硬件会自动把BL指令的下一条指令的地址保存到LR;
BL嵌套使用时,要注意保护LR
   一般是把LR入栈,在子函数返回后再出栈;

   bl func1

func1:
   stmfd  sp!, {lr}
   bl  func2
   ldmfd  sp!, {pc}
  
-------------------------------------------
  .text
  .code 32
  .global main
main:
    stmfd   sp!, {lr}   @把lr入栈
    bl          func1   
    ldmfd   sp!, {pc}   @把入栈lr出给pc
                        @返回到调用main
func1:
   stmfd  sp!, {lr}
   bl  func2
   ldmfd  sp!, {pc}

func2:
    mov   pc,  lr
    .end
-------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                               
   调用子函数属于哪种异常?
      不属于异常;
   BL 修改R14,R14有6个;
   修改哪个模式的R14呢?
       修改当前模式的R14;
       BL指令是标准的子程序调用指令;
       不涉及模式切换;
   假如当前在SVC(管理模式下执行)
      bl func1
      R14 就是管理模式的R14
   如果我代码是在IRQ模式运行的
      bl func1
      R14 修改的IRQ模式的R14

   复位后处理器进入管理模式,如果没有发生异常,并且你没有主动切换模式;
   就一直在管理模式;
   

  





   
  






