nand driver
net driver/dm9000
OOPS


回顾:
LCD驱动框架:
1.掌握LCD核心层的内容:fbmem.c
  注册一个字符设备
  fb_fops:其中的接口严重依赖fb_info
2.驱动程序的实现重点是围绕着fb_info
  2.1分配fb_info
  2.2根据屏的相关参数初始化fb_info
  2.3调用register_framebuffer向核心层注册fb_info
  结果:核心层注册的fb_fops这些接口就可用使用fb_info
  2.4硬件相关的初始化
     GPIO复用
     地址映射
     LCD控制器相关寄存器的初始化
重点:LCD驱动的移植
---------------------------------------------------------
nandflash:
硬件接口
nandflash的操作步骤:命令,地址,数据
uboot如何操作nand:nand erase,nand write, nand read,nand dump
在linux系统中如何使用操作nand
1.查看nand的分区信息:cat /proc/mtd
2.查看每一个分区对应的块设备节点和字符设备节点
  ls /dev/mtd* (块:/dev/mtdblock0,/dev/mtd0)
3.掌握块设备节点和字符设备节点如何使用
  块设备节点:mount
  字符设备节点:flash_eraseall,nandwrite,nanddump
  三个工具:busybox或者mtd-utils-05.07.23.tar.bz2
  案例:在设备操作维护软件中添加软件在线升级功能(比如升级zImage)
4.掌握nand的分区,如何分区
  分区表:一般都是在定义在驱动程序或者平台代码中或者uboot指定!
----------------------------------------------------------
linux内核nand驱动框架:
app:mount,cp,mkdir  挂接,拷贝文件,创建目录
----------------------------------------------------------
	文件系统层
----------------------------------------------------------
	块设备驱动层:
        优化nand的读写访问(电梯算法)
---------------------------------------------------
	nand协议层:
	实现发送哪个命令和地址和数据
        协议层知道发什么命令,什么地址和数据信息,
        但是不知道如何去发送这些信息,因为硬件接口上有
        差异(有的处理器有nand控制器,有的没有,最终导致发送方式不一样),内核不做此事
----------------------------------------------------
    nand驱动层:
    帮你实现发送命令,地址和数据,不关心这些数据怎么来得!比如210通过寄存器来实现发送命令,地址和数据,别的处理器可能通过操作GPIO来实现发送命令,地址,和数据

问:nand协议层只知道操作的命令,地址和数据,但是不知道如何将这些信息通过硬件发送出去,但是nand底层驱动知道如何来进行发送这些数据,nand驱动层如何将这些发送命令,地址和数据的方法提交给nand协议层,知道nand协议层拿到了nand底层操作数据的方法,就可用实现对nand的访问操作!

答:nand底层驱动只需关心围绕nand_chip和mtd_info结构体即可. nand_chip结构中完成对底层硬件数据传输的封装. 

如何写一个nand驱动程序?
1.分配nand_chip和mtd_info
2.根据底层硬件的操作方法(控制器来发,GPIO来发)
  将nand_chip中的相关操作函数进行初始化:
  使能片选函数
  发送命令函数,
  发送地址函数,
  发送数据的函数
  判断nand状态的函数
  ECC校验的函数
3.调用nand_scan_ident进行扫描识别开发板nand信息
4.调用nand_scan_tail进行初始化mtd_info(nand协议层给块设备  层使用,mtd_info内部相关函数的实现严重依赖nand_chip)
5.添加注册分区表
6.硬件相关的初始化
  GPIO的复用
  地址映射
  初始化nand控制器相关的寄存器
切记:nand底层驱动就是仅仅就是外绕着硬件接口的特性,实现最底层的硬件操作封装~!

通过阅读nand_scan_ident函数发现,nand_chip虽然在协议层,协议层也做了一些初始化工作,但是这些初始化工作的结果不能满足驱动的要求. 所有需要底层重新对nand_chip进行初始化. 
初始化片选函数select_chip
初始化发送命令,地址的函数cmd_ctrl
读写的函数:IO_ADDR_R,IO_ADDR_W
判断nand状态函数dev_ready

测试nand驱动:
1.卸载三星官方的nand驱动
  make menuconfig
  Device Driver->
	 <*> Memory Technology Device (MTD) support  ---> 
		 <*>   NAND Device Support  --->  
			 <*>   NAND Flash support for S3C SoC  //去掉
 make zImage //用新内核重新引导系统
2.insmod nand_drv.ko //查看打印信息,看看nand是否识别到信息
NAND device: Manufacturer ID: 0xec, Chip ID: 0xd3 (Samsung NAND 1GiB 3,3V 8-bit) //扫描到的nandflash信息

NAND_ECC_NONE selected by board driver. This is not recommended !!
Scanning device for bad blocks
Bad eraseblock 189 at 0x0000017a0000 //扫描nand上的坏块
//创建了四个分区
Creating 4 MTD partitions on "NAND 1GiB 3,3V 8-bit":
分区的起始地址 分区的结束地址   分区名称
0x000000000000-0x000000200000 : "uboot"
0x000000200000-0x000000700000 : "kernel"
0x000000700000-0x000000c00000 : "ramdisk"
0x000000c00000-0x000040000000 : "userdata"

3.查看分区信息 cat /proc/mtd
4.查看每个分区对应的设备节点,进一步测试

---------------------------------------------------------
DM9000网卡的硬件特性:
1.DATA0~DATA15:数据线
2.CMD:CMD=0时,数据线传输的是DM9000内部寄存器的地址,表明要访问的是哪个寄存器
       CMD=1时,数据线传输的是DM9000内部寄存器的数据,表明要访问寄存器中的数据
3.CS:片选信号,通过原理图和CPU的地址映射表可以得到DM9000的基地址:0x88000000,并且操作的地址也只有两个:0x88000000和0x88000000+4,cpu访问这两个地址都会拉低片选信号!
4.INT:外部中断10,触发中断的因素:1.DM9000网卡接受到数据产生中断;2.DM9000发送完数据以后产生中断,3.链路发生变化产生中断. 
5.EECS:高电平,采用8bit模式
       低电平,采用16bit模式
6.EECK:高电平,中断低电平触发
       低电平,中断高电平触发

DM9000如何接受数据包和发送数据包:
发送数据包:
DM9000内部集成了16K的SRAM,前3K用于发送缓冲区
后13K用于接受缓冲区. 
1.将第一包发送的数据写入到TX SRAM中
2.将第一包的数据长度告诉DM9000(就是将长度写入到DM9000内部的长度寄存器中即可)
3.设置发送控制器寄存器,启动DM9000硬件传输
4.在发送完第一包之前,可用把第二包数据写入TX SRAM中,
5.当第一包数据发送完毕,将第二包的数据长度告诉DM9000,
6.设置发送控制器寄存器,启动DM9000第二包的数据传输
7.如果有第三包数据,只有第一包数据DM9000硬件发送完以后,这时DM9000给CPU发送一个发送中断信号,CPU就会将第三包数据放到TX SRAM中. 

接受数据包:
1.DM9000接受数据包到RX SRAM中(硬件来做)
2.DM9000给CPU发送一个接受中断信号,告诉CPU,有数据包到来,请赶紧读走(从DM9000的RX SRAM中读到内存中)!
3.在中断处理函数中,首先CPU判断RX SRAM中数据包的有效性,如果正常,继续读取,否则丢弃!
4.每一个数据包前面都有4字节的数据头,第一字节是数据包的有效性标志,如果=1,数据包OK,否则有问题;
第二字节是数据包的状态信息;
第三字节是数据包长度的低位;
第四字节是数据包长度的高位;
只要其中有一个有问题,数据包都要丢弃,只有全部OK,才能去读取数据包!
5.后续数据包递交给协议层

注意:不管是发包还是接受数据包都要涉及中断!
---------------------------------------------------------
linux内核网络设备驱动框架:
app:socket();sendto,recvfrom
-------------------------------------
    网络协议层
    ----------
    ----------
    ---------- (纯软件)
    ----------
     数据链路层
    -----------
-----------------------------------
     网卡驱动:
     1.将网络协议层的数据包通过操作网卡硬件将数据包发送出去. 网卡驱动会将发包过程封装在ndo_start_xmit函数,并且将此函数提交给协议层使用. 每当协议层进行发包时,通过这个函数ndo_start_xmit来完成硬件传输. 

     2.将网卡接受到的数据包读到内存中,然后递交给协议层. 
       一旦网卡接受到数据包以后,网卡驱动程序调用netif_rx最终将数据包递交协议层. 此函数由协议层来实现. 
-----------------------------------
    物理层

linux内核如何去描述一个网卡设备,和描述这个网卡设备具有的处理出数据包的功能. 
答:linux内核通过struct net_device来描述一个网卡设备. 
如何使用?如何写一个网卡驱动?
1.分配struct net_device
	alloc_etherdev
2.初始化struct net_device
3.向协议层注册网卡设备net_device
4.硬件相关的初始化
  GPIO的复用
  地址映射
  注册中断处理函数

案例:实现虚拟网卡
测试步骤:
insmod virnetdevice.ko
ifconfig vndcard up //打开网卡
ifconfig vndcard 3.3.3.3
ping 3.3.3.3 //ping自己
ping 3.3.3.4 //ping别的网卡
ifconfig vndcard down

DM9000官方网卡驱动分析:drivers/net/dm9000.c
dm9000网卡的硬件资源信息:
网卡的索引寄存器0x88000000:通过这个地址能够指定要访问dm9000内部的某个寄存器
网卡的数据寄存器0x88000004:通过这个地址能够访问dm9000网卡内部寄存器的数据
网卡的中断号资源IRQ_EINT10

dm9000_probe:
//1.分配net_device
struct net_device *ndev = alloc_etherdev(0);
//2.获取网卡的三个硬件资源信息:0x88000000,0x88000004,IRQ_EINT10
//3.处理硬件资源信息:ioremap,将物理地址映射到内核虚拟地址
//4.复位dm9000,注意复位的过程要操作DM9000内部相关的寄存器,操作寄存器要设计以上两个地址的操作. 
//5.ether_setup(ndev);初始化net_device协议相关的字段信息
//6.初始化网卡硬件操作的方法和接口
    ndev->netdev_ops	= &dm9000_netdev_ops;
	//ifconfig eth0 up
   	.ndo_open		= dm9000_open,
	//ifconfig eth0 down
	.ndo_stop		= dm9000_stop,
	//发包时调用
	.ndo_start_xmit		= dm9000_start_xmit,
//7.register_netdev(ndev);向协议层注册dm9000网卡设备
//8.中断处理函数何时何地被注册的?答:每当打开网卡时,注册网卡对应的中断处理函数

dm9000_open:打开网卡
1.注册网卡中断处理函数dm9000_interrupt
2.复位dm9000网卡
3.初始化dm9000网卡
4.调用netif_start_queue(dev);通知协议层网卡准备就绪,可用使用,启动发包队列. 

dm9000_stop:关闭网卡
1.netif_stop_queue(ndev);//通知协议层,停止发送队列
2.释放中断
3.关闭网卡

dm9000_start_xmit:协议层的发包函数实现
1.协议层调用此函数将第一包数据填充到TX SRAM中
2.tx_pkg_cnt++, 发包计数加1
3.如果是第一包数据,启动DM9000硬件发包过程
4.协议层再次调用此函数发送第二包,将第二包填充到TX SRAM中
5.tx_pkg_cnt++
6.netif_stop_queue通知协议层不要再发包

结合中断处理函数:
7.一旦第一包发送完毕,dm9000给cpu发送一个发送中断信号
8.tx_pkg_cnt--;
9.判断TX SRAM中是否有第二包数据,如果有,启动DM9000硬件传输
10.调用netif_wake_queue通知协议层启动第三包的数据传输

总结:发包函数ndo_start_xmit一定要结合中断处理函数一起来研究!


接受数据包过程:一旦DM9000网卡接受到数据包,会给CPU发送一个接受中断信号,内核执行中断处理函数:
dm9000_interrupt:
dm9000_rx:接受数据包的过程:
1.读取RX SRAM中的前四节数据
  判断第一字节是否为1,如果不为1,丢弃
  判断数据包的长度
  判断数据包的状态
2.如果数据正常,将数据包从RX SRAM中读取到内存中
3.调用dev_alloc_skb分配数据包的缓冲区,长度是数据包大小  	
4.调用一下两个函数处理缓冲区:
  skb_reserve(skb, 2);
  skb_put(skb, RxLen - 4);
5.通过操作dm9000内部寄存器将RX SRAM中的数据读到3步分配的缓冲区
6.调用eth_type_trans(skb, dev)此函数对缓冲区数据进行修饰
7.调用netif_rx(skb);将缓冲区的数据包提交给协议层. 

----------------------------------------------------------
OOPS:linux内核崩溃
引起OOPS的情形:
1.驱动以模块形式引起的OOPS问题
/ # insmod led_drv.ko 
/ # ./led_test 
usage:
 ./led_test <on|off> <1|2>
/ # ./led_test on 1
Unable to handle kernel paging request at virtual address 00100100 //0x00100100属于一个非法地址

pgd = f353c000
[00100100] *pgd=534b9031, *pte=00000000, *ppte=00000000
Internal error: Oops: 17 [#1] PREEMPT
last sysfs file: /sys/devices/virtual/leds/myled/dev

Modules linked in: led_drv //可能引起oops的模块

CPU: 0    Not tainted  (2.6.35.7-Concenwit #6)
//内核崩溃运行的地址:找到出现问题的函数是led_ioctl函数,
模块是led_drv
PC is at led_ioctl+0x78/0x114 [led_drv]

LR is at 0x1
//内核崩溃时,各个寄存器中的数据
pc : [<bf000188>]    lr : [<00000001>]    psr: 60000013
sp : f34e9ed0  ip : 0000001c  fp : f34e9eec
r10: 00000000  r9 : f34e8000  r8 : 00000000
r7 : 00100001  r6 : be920b40  r5 : ff920b43  r4 : 00100001
r3 : bf000430  r2 : 00100001  r1 : 00100100  r0 : 00000000

Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
Control: 10c5387d  Table: 5353c019  DAC: 00000015

SP: 0xf34e9e50:
9e50  f34b7c28 f347d480 f34e9ecc f34e9e68 c00d8fd4 c00d8130 ffffffff f34e9ebc
9e70  be920b40 00100001 f34e9eec f34e9e88 c0037a6c c00372ac 00000000 00100100
9e90  00100001 bf000430 00100001 ff920b43 be920b40 00100001 00000000 f34e8000
9eb0  00000000 f34e9eec 0000001c f34e9ed0 00000001 bf000188 60000013 ffffffff
9ed0  00000000 00000001 f34b2780 00000000 f34e9f0c f34e9ef0 c00fa52c bf00011c
9ef0  be920b40 f34b2780 00100001 00000003 f34e9f74 f34e9f10 c00fabbc c00fa4b4
9f10  00000000 00000003 00000000 f34b2780 f34e9f54 f34e9f30 c023eaec c023b35c
9f30  c0851990 f34b2780 be920b40 00100001 00000003 c0038168 f34e9f64 f34e9f58

FP: 0xf34e9e6c:
9e6c  f34e9ebc be920b40 00100001 f34e9eec f34e9e88 c0037a6c c00372ac 00000000
9e8c  00100100 00100001 bf000430 00100001 ff920b43 be920b40 00100001 00000000
9eac  f34e8000 00000000 f34e9eec 0000001c f34e9ed0 00000001 bf000188 60000013
9ecc  ffffffff 00000000 00000001 f34b2780 00000000 f34e9f0c f34e9ef0 c00fa52c
9eec  bf00011c be920b40 f34b2780 00100001 00000003 f34e9f74 f34e9f10 c00fabbc
9f0c  c00fa4b4 00000000 00000003 00000000 f34b2780 f34e9f54 f34e9f30 c023eaec
9f2c  c023b35c c0851990 f34b2780 be920b40 00100001 00000003 c0038168 f34e9f64
9f4c  f34e9f58 f34b2780 be920b40 00100001 00000003 00000000 f34e8000 f34e9fa4

R5: 0xff920ac3:
0ac0  ******** ******** ******** ******** ******** ******** ******** ********
0ae0  ******** ******** ******** ******** ******** ******** ******** ********
0b00  ******** ******** ******** ******** ******** ******** ******** ********
0b20  ******** ******** ******** ******** ******** ******** ******** ********
0b40  ******** ******** ******** ******** ******** ******** ******** ********
0b60  ******** ******** ******** ******** ******** ******** ******** ********
0b80  ******** ******** ******** ******** ******** ******** ******** ********
0ba0  ******** ******** ******** ******** ******** ******** ******** ********
0bc0  ******** ******** ******** ******** ******** ******** ******** ********

R9: 0xf34e7f80:
7f80  0000ffff 000a2f3c f34e7fa4 f34e7f98 c006951c c0069428 00000000 f34e7fa8
7fa0  c0037fc0 c0069510 000a2f3c 4020b774 00000000 000a2f28 00000008 00000000
7fc0  000a2f3c 4020b774 4020b774 000000f8 401380a4 00000000 000f1870 00000000
7fe0  00000000 bed06cd0 400fc4b4 4016a210 60000010 00000000 210f8021 210f8421
8000  00000000 00000003 00000000 f348b200 c083fc90 00000000 00000017 f34e8000
8020  f348b200 c08334d8 00000000 f347d480 00000000 00000001 f34e9c5c f34e9c38
8040  c05d3d18 00000000 00000000 00000000 00000000 00000000 01000000 00000000
8060  4001f610 00000000 00000000 00000000 00000000 00000000 00000000 00000000
//引起内核崩溃的进程
Process led_test (pid: 66, stack limit = 0xf34e82f0)

Stack: (0xf34e9ed0 to 0xf34ea000)
9ec0:                                     00000000 00000001 f34b2780 00000000
9ee0: f34e9f0c f34e9ef0 c00fa52c bf00011c be920b40 f34b2780 00100001 00000003
9f00: f34e9f74 f34e9f10 c00fabbc c00fa4b4 00000000 00000003 00000000 f34b2780
9f20: f34e9f54 f34e9f30 c023eaec c023b35c c0851990 f34b2780 be920b40 00100001
9f40: 00000003 c0038168 f34e9f64 f34e9f58 f34b2780 be920b40 00100001 00000003
9f60: 00000000 f34e8000 f34e9fa4 f34e9f78 c00fac5c c00fa668 00000005 00000000
9f80: f34e8000 0000854c 00000140 00000000 00000036 c0038168 00000000 f34e9fa8
9fa0: c0037fc0 c00fac10 0000854c 00000140 00000003 00100001 be920b40 be920b40
9fc0: 0000854c 00000140 00000000 00000036 00000000 00000000 40180b60 be920b4c
9fe0: 00000000 be920b38 00008618 4010ac3c 60000010 00000003 00000000 00000000
回溯信息:从后往前看
Backtrace: 
[<bf000110>] (led_ioctl+0x0/0x114 [led_drv]) from [<c00fa52c>] (vfs_ioctl+0x84/0xb4)
 r5:00000000 r4:f34b2780
[<c00fa4a8>] (vfs_ioctl+0x0/0xb4) from [<c00fabbc>] (do_vfs_ioctl+0x560/0x5a8)
 r7:00000003 r6:00100001 r5:f34b2780 r4:be920b40
[<c00fa65c>] (do_vfs_ioctl+0x0/0x5a8) from [<c00fac5c>] (sys_ioctl+0x58/0x7c)
 r9:f34e8000 r8:00000000 r7:00000003 r6:00100001 r5:be920b40
r4:f34b2780
[<c00fac04>] (sys_ioctl+0x0/0x7c) from [<c0037fc0>] (ret_fast_syscall+0x0/0x30)
 r8:c0038168 r7:00000036 r6:00000000 r5:00000140 r4:0000854c
Code: e59f3094 e59f2094 e593104c e1540002 (e5912000) 
---[ end trace d8e9bd12292ae0bc ]---
Segmentation fault

有时崩溃提示的信息只提供pc指针的内容:pc : [<bf000188>] 
解决方法如下:
1.在崩溃的开发板上执行
   cat /proc/kallsyms > symbol.txt //将内核所有的函数信息保存在symbol.txt文件
2.在这个文件中,找到跟pc指针最近的一个地址,信息如下:
  函数地址   函数        模块
  bf000110 t led_ioctl	[led_drv] //确定是此模块
3.反汇编led_drv.ko,获取反汇编文件led_drv.dis
  arm-linux-objdump -D led_drv.ko > led_drv.dis
4.打开反汇编文件,找到led_ioctl函数信息:
  函数地址  函数名
  00000110 <led_ioctl>
5.通过对比led_ioctl函数在symbol.txt和led_drv.dis的信息得到
  pc指针在led_drv.dis文件中的地址:
symbol.txt  bf000110  led_ioctl   bf000188  pc
led_drv.dis 00000110  led_ioctl       B     pc
 B = bf000188 - (bf000110 - 00000110) = 188
pc在led_drv.dis文件中的地址是0x188,信息如下:
188:	e5912000 	ldr	r2, [r1]
基本确定:出现问题的函数就是led_ioctl.
6.在看内核崩溃各个寄存器的值:r1 : 00100100,说明程序访问了0x00100100这个地址
7.在程序中反推在哪里使用了这个地址信息!

2.驱动静态编译到内核引起的OOPS问题. 
 cp led_drv.ko /opt/kernel/drivers/char
 进入内核源码/opt/kernel
 vim drivers/char/Makefile,添加以下代码
 obj-y += led_drv.o //静态编译
 make zImage //内核就有led_drv驱动

/ # ./led_test on 1
Unable to handle kernel paging request at virtual address 00100100
pgd = f353c000
[00100100] *pgd=534b6031, *pte=00000000, *ppte=00000000
Internal error: Oops: 17 [#1] PREEMPT
last sysfs file: /sys/devices/virtual/video4linux/video21/dev
Modules linked in:
CPU: 0    Not tainted  (2.6.35.7-Concenwit #7)
PC is at led_ioctl+0x78/0x114
LR is at 0x1
pc : [<c02a4ce4>]    lr : [<00000001>]    psr: 60000013
sp : f34f9ed0  ip : 0000001c  fp : f34f9eec
r10: 00000000  r9 : f34f8000  r8 : 00000000
r7 : 00100001  r6 : beba7b40  r5 : ffba7b43  r4 : 00100001
r3 : c08dd1bc  r2 : 00100001  r1 : 00100100  r0 : 00000000
Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
Control: 10c5387d  Table: 5353c019  DAC: 00000015

PC: 0xc02a4c64:
4c64  c07ba861 00100100 e1a0c00d e92dd830 e24cb004 e24dd008 e1a0100d e3c1cd7f
4c84  e59f10e4 e3ccc03f e1a04002 e24b0018 e59c2008 e591c044 e2935004 30d55002
4ca4  33a02000 e3520000 e28ce004 e581c048 e581e04c 1a000003 e1a01003 e2822004
4cc4  ebff1838 ea000001 e3a01004 ebff2172 e59f3094 e59f2094 e5931048 e1540002
4ce4  e5912000 e3c22aff e3822a11 e5812000 e593304c e5932000 e3c22018 e5832000
4d04  0a000004 e59f0068 e1540000 13e00000 1a000013 ea000007 e51b0018 e3500001
4d24  03822008 0a000008 e3500002 03822010 1a000006 ea000004 e51b0018 e3500001
4d44  0a000001 e3500002 1a000000 e5832000 e5911000 e5932000 e59f0018 eb0cbb65

SP: 0xf34f9e50:
9e50  f34acc28 f347e180 f34f9ecc f34f9e68 c00d8fd4 c00d8130 ffffffff f34f9ebc
9e70  beba7b40 00100001 f34f9eec f34f9e88 c0037a6c c00372ac 00000000 00100100
9e90  00100001 c08dd1bc 00100001 ffba7b43 beba7b40 00100001 00000000 f34f8000
9eb0  00000000 f34f9eec 0000001c f34f9ed0 00000001 c02a4ce4 60000013 ffffffff
9ed0  00000000 00000001 f34bf300 00000000 f34f9f0c f34f9ef0 c00fa52c c02a4c78
9ef0  beba7b40 f34bf300 00100001 00000003 f34f9f74 f34f9f10 c00fabbc c00fa4b4
9f10  00000000 00000003 00000000 f34bf300 f34f9f54 f34f9f30 c023eaec c023b35c
9f30  c0851990 f34bf300 beba7b40 00100001 00000003 c0038168 f34f9f64 f34f9f58

FP: 0xf34f9e6c:
9e6c  f34f9ebc beba7b40 00100001 f34f9eec f34f9e88 c0037a6c c00372ac 00000000
9e8c  00100100 00100001 c08dd1bc 00100001 ffba7b43 beba7b40 00100001 00000000
9eac  f34f8000 00000000 f34f9eec 0000001c f34f9ed0 00000001 c02a4ce4 60000013
9ecc  ffffffff 00000000 00000001 f34bf300 00000000 f34f9f0c f34f9ef0 c00fa52c
9eec  c02a4c78 beba7b40 f34bf300 00100001 00000003 f34f9f74 f34f9f10 c00fabbc
9f0c  c00fa4b4 00000000 00000003 00000000 f34bf300 f34f9f54 f34f9f30 c023eaec
9f2c  c023b35c c0851990 f34bf300 beba7b40 00100001 00000003 c0038168 f34f9f64
9f4c  f34f9f58 f34bf300 beba7b40 00100001 00000003 00000000 f34f8000 f34f9fa4

R3: 0xc08dd13c:
d13c  00000000 c085ba28 00000000 c0868d70 c08617a0 00000000 00000000 00000000
d15c  00000000 00000000 00000000 00000000 00000000 00000000 00000000 c08617fc
d17c  c08e2a48 00000000 00000000 00000000 00000000 00000000 00000000 00000000
d19c  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
d1bc  000000fd 00000000 c08dd1c4 c08dd1c4 00000000 00000000 c084cfe0 00000000
d1dc  00000002 00000001 00000000 c085ba80 f3536968 f3536968 0fd00000 00000001
d1fc  f3de7680 00100100 00100100 00100104 00000000 f3f613c0 f3f61480 00000000
d21c  c00eae2c c029b0a0 c029c988 00000000 00000000 00000000 c029afa4 00000000

R5: 0xffba7ac3:
7ac0  ******** ******** ******** ******** ******** ******** ******** ********
7ae0  ******** ******** ******** ******** ******** ******** ******** ********
7b00  ******** ******** ******** ******** ******** ******** ******** ********
7b20  ******** ******** ******** ******** ******** ******** ******** ********
7b40  ******** ******** ******** ******** ******** ******** ******** ********
7b60  ******** ******** ******** ******** ******** ******** ******** ********
7b80  ******** ******** ******** ******** ******** ******** ******** ********
7ba0  ******** ******** ******** ******** ******** ******** ******** ********
7bc0  ******** ******** ******** ******** ******** ******** ******** ********

R9: 0xf34f7f80:
7f80  210fb041 210fb441 e2611452 00000000 00000000 00000000 21100041 21100441
7fa0  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
7fc0  53c29011 53c29411 53c2a011 53c2a411 53c2b011 53c2b411 53c2c011 53c2c411
7fe0  53c2d011 53c2d411 53c2e011 53c2e411 53c2f011 53c2f411 210f8021 210f8421
8000  00000000 00000003 00000000 f348a600 c083fc90 00000000 00000017 f34f8000
8020  f348a600 c08334d8 00000000 f347e180 00000000 00000001 f34f9c5c f34f9c38
8040  c05d3f38 00000000 00000000 00000000 00000000 00000000 01000000 00000000
8060  4001f610 00000000 00000000 00000000 00000000 00000000 00000000 00000000
Process led_test (pid: 61, stack limit = 0xf34f82f0)
Stack: (0xf34f9ed0 to 0xf34fa000)
9ec0:                                     00000000 00000001 f34bf300 00000000
9ee0: f34f9f0c f34f9ef0 c00fa52c c02a4c78 beba7b40 f34bf300 00100001 00000003
9f00: f34f9f74 f34f9f10 c00fabbc c00fa4b4 00000000 00000003 00000000 f34bf300
9f20: f34f9f54 f34f9f30 c023eaec c023b35c c0851990 f34bf300 beba7b40 00100001
9f40: 00000003 c0038168 f34f9f64 f34f9f58 f34bf300 beba7b40 00100001 00000003
9f60: 00000000 f34f8000 f34f9fa4 f34f9f78 c00fac5c c00fa668 00000005 00000000
9f80: f34f8000 0000854c 00000140 00000000 00000036 c0038168 00000000 f34f9fa8
9fa0: c0037fc0 c00fac10 0000854c 00000140 00000003 00100001 beba7b40 beba7b40
9fc0: 0000854c 00000140 00000000 00000036 00000000 00000000 40180b60 beba7b4c
9fe0: 00000000 beba7b38 00008618 4010ac3c 60000010 00000003 00000000 00000000
Backtrace: 
[<c02a4c6c>] (led_ioctl+0x0/0x114) from [<c00fa52c>] (vfs_ioctl+0x84/0xb4)
 r5:00000000 r4:f34bf300
[<c00fa4a8>] (vfs_ioctl+0x0/0xb4) from [<c00fabbc>] (do_vfs_ioctl+0x560/0x5a8)
 r7:00000003 r6:00100001 r5:f34bf300 r4:beba7b40
[<c00fa65c>] (do_vfs_ioctl+0x0/0x5a8) from [<c00fac5c>] (sys_ioctl+0x58/0x7c)
 r9:f34f8000 r8:00000000 r7:00000003 r6:00100001 r5:beba7b40
r4:f34bf300
[<c00fac04>] (sys_ioctl+0x0/0x7c) from [<c0037fc0>] (ret_fast_syscall+0x0/0x30)
 r8:c0038168 r7:00000036 r6:00000000 r5:00000140 r4:0000854c
Code: e59f3094 e59f2094 e5931048 e1540002 (e5912000) 
---[ end trace 507eda5b957fdaf5 ]---
Segmentation fault

如果仅仅只告诉pc的信息:pc : [<c02a4ce4>]
1.反汇编内核原始镜像文件vmlinux
2.进入内核源码cd /opt/kernel
3.执行arm-linux-objdump -D vmlinux > vmlinux.dis
4.打开vmlinux.dis,在文件中找到pc的值c02a4ce4,信息如下:
  c02a4ce4:	e5912000 	ldr	r2, [r1]
5.获取这句话所在函数:c02a4c6c <led_ioctl>:
6.看内核崩溃时r1寄存器中的数据: r1 : 00100100
7.看代码,反推哪个地方使用这个地址
  









